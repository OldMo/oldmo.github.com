---
layout: post
title: "C# TCP/IP服务器端程序(未完成)"
description: ""
category: 工作生涯
tags: [TCP/IP]
---

###同步和异步同步
服务器只能一个接着一个响应客户端请求，如果前一个客户端的请求未处理完成，此时再进来其他的客户端请求，这些后来的请求则只能等待。
异步
服务器能够同时相应多个客户端，只要客户端发起连接，服务器就能并行处理，跟其他客户端操作是否完成没有关系。C#中异步方法通过
BeginAcceptTcpClient() EndAcceptTcpClient() 两个操作来完成。

###程序中的一些概念：
创建TCP连接监听并开启监听，参数为监听IP和端口

    tcpListener = new TcpListener (SharedUtilities.Net.NetworkTools.GetLocalIP(), port);
    tcpListener.Start();

AsyncCallback委托，在异步操作完成时将调用方法AcceptTcpClientCallBack，该回调方法的是参数为IAsyncResult，该参数用来获取异步操作的结果。

    public delegate void AsyncCallback(
        IAsyncResult ar
   )

    AsyncCallback callBack = new AsyncCallback(AcceptTcpClientCallBack);
    allDone.Reset();
    allDone.WaitOne();


开启异步操作来实现tcp连接的接入操作，异步操作完成后将调用callBack中的AcceptTcpClientCallBack方法，同时将tcpListerner异步传输到该方法中

    tcpListener.BeginAcceptTcpClient(callBack, tcpListener);
    
该方法定义如下

    public IAsyncResult BeginAcceptTcpClient(
        AsyncCallback callback,
        Object state
    )

callback是一个委托，用来引用异步操作完成时要调用到的方法

state是用户定义对象，操作完成时会通过callback传递给调用的方法


表示异步操作的状态，其中的一个成员AsyncState用于获取用户定义的对象，它限定或包含关于异步操作的信息；异步调用完成时，WaitHandle 会收到信号  

    IAsyncResult
    TcpListener myListener = (TcpListener )ar.AsyncState;
通过IAsyncResult获取传输过来的Listener对象  

     client = myListener.EndAcceptTcpClient(ar);

EndAcceptTcpClient定义如下：

    public TcpClient EndAcceptTcpClient(
        IAsyncResult asyncResult
    )

asyncResult是BeginAcceptTcpClient的返回

异步接受接入的连接，创建新的TcpClient处理远程主机的通信，相当于是建立了一个连接之后，建立了一个client来进行发送和接收数据的通信

BeginRead开启异步读取数据  

    readWriteObject.netStream.BeginRead(readWriteObject.readBytes, 0, readWriteObject.readBytes.Length, ReadThread,         readWriteObject);
    length = readWriteObject.netStream.EndRead(ar);


###代码实现


        #region 监听与结果的处理
        /// <summary>
        /// 异步执行
        /// </summary>
        public void ListenClientConnect()
        {
            //开始监听
            tcpListener = new TcpListener (SharedUtilities.Net.NetworkTools.GetLocalIP(), port);
            tcpListener.Start();
            AsyncCallback callBack = new AsyncCallback(AcceptTcpClientCallBack);
            while (!isStop)
            {
                try
                {
                    allDone.Reset();
                   //开始一个异步操作接受传入的连接尝试
                    tcpListener.BeginAcceptTcpClient(callBack, tcpListener);
                    //阻塞当前线程，直到收到客户连接信号
                    allDone.WaitOne();
                    Thread.Sleep(100);
                }
                catch (Exception ex)
                {
                    log.ErrorFormat( "侦听服务出错：{0}——{1}" , ex.InnerException == null ? ex.Message : (ex.InnerException.Message ?? ex.Message), DateTime .Now);
                    break;
                }
            }
            try
            {
                if (clients != null && clients.Count > 0)
                {
                    foreach (var client in clients)
                    {
                        try
                        {
                            client.Close();
                        }
                        catch
                        {
                        }
                    }
                }
                CloseSocket();
            }
            catch
            {
            }
        }
        List<TcpClient > clients = new List< TcpClient>();
        /// <summary>
        ///  tcpListener.BeginAcceptTcpClient(callBack, tcpListener);
        /// </summary>
        /// <param name="ar"></param>
        private void AcceptTcpClientCallBack(IAsyncResult ar)
        {
            allDone.Set();
            TcpListener myListener = (TcpListener )ar.AsyncState;
            TcpClient client = null ;// myListener.EndAcceptTcpClient(ar);
            try
            {
                client = myListener.EndAcceptTcpClient(ar);
                lock (clients)
                {
                    //#region 增加的代码，解决有一个端点出错，服务端收不到数据的问题。
                    LingerOption lingerOption = new LingerOption( true, 10);
                    client.LingerState = lingerOption;
                    byte[] inOptionValues = new byte[sizeof( uint) * 3];
                    BitConverter.GetBytes((uint )1).CopyTo(inOptionValues, 0);
                    BitConverter.GetBytes((uint )120000).CopyTo(inOptionValues, sizeof( uint));
                    BitConverter.GetBytes((uint )3000).CopyTo(inOptionValues, sizeof( uint) * 2);
                    client.Client.IOControl( IOControlCode.KeepAliveValues, inOptionValues, null);
                    //#endregion  增加的代码，解决有一个端点出错，服务端收不到数据的问题。
                    clients.Add(client);
                }
                Debug.WriteLine(string .Format("接受一次连接：{0}——{1}:当前连接数：{2}" , client.Client.RemoteEndPoint, DateTime .Now, clients.Count()));
                if (client != null )
                {
                    ReadWriteObject readWriteObject = new ReadWriteObject(client);
                    if (readWriteObject.netStream.CanRead)
                    {
                        readWriteObject.netStream.BeginRead(readWriteObject.readBytes, 0, readWriteObject.readBytes.Length, ReadThread, readWriteObject);
                    }
                }
            }
            catch (Exception ex)
            {
                try
                {
                    if (client != null )
                    {
                        client.Close();
                        client = null;
                    }
                }
                catch { }
                Debug.WriteLine(string .Format("接受连接时出错：{0}——{1}" , ex.InnerException == null ? ex.Message : (ex.InnerException.Message ?? ex.Message), DateTime .Now));
                return;
            }
        }
        private void ReadThread(IAsyncResult ar)
        {
            ReadWriteObject readWriteObject = (ReadWriteObject )ar.AsyncState;
            try
            {
                int length = 0;
                try
                {
                    length = readWriteObject.netStream.EndRead(ar);
                }
                catch (Exception e)
                {
                    log.ErrorFormat( "EndRead异常，信息：{0}" , e.Message);
                        //客户端强制关闭
                    CloseClient(readWriteObject.client);
                    return;
                }
                byte[] buff = new byte[1024 * 8];
                Array.Copy(readWriteObject.readBytes, 0, buff, 0, buff.Length);
                if (length == 0)
                {
                    CloseClient(readWriteObject.client);
                }
                else
                {
                    string machineId = "" ;
                    string str = Encoding .Default.GetString(buff, 0, length).Replace("\r\n", "").ToUpper();
                    Debug.WriteLine(buff.ByteArrayToHexString2(0, length));
                    Debug.WriteLine(str);
                    string patrolInfo = buff.ByteArrayToHexString2(0, length);
                    Debug.WriteLine(string .Format("接收信息：{0}  接收时间：{1}" , patrolInfo, DateTime.Now));
                }
                //未停止则继续接收信息
            
                 if (!isStop)
                 {
                    try
                    {
                        readWriteObject.InitReadArray();
                        readWriteObject.netStream.BeginRead(readWriteObject.readBytes, 0, readWriteObject.readBytes.Length, ReadThread, readWriteObject);
                    }
                    catch (Exception e)
                    {
                        log.ErrorFormat( "继续接收异常：{0}" , e.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                log.ErrorFormat( "异常信息：{0}" , ex.Message);
                CloseClient(readWriteObject.client);
            }
            #endregion
        }
        public void CloseClient(TcpClient client)
        {
            if (this .clients.Count > 0)
            {
                this.clients.Remove(client);
            }
            Debug.WriteLine(string .Format("断开连接：当前连接数：{0}" , this.clients.Count));
            if (client != null )
            {
                client.Close();
                client = null;
            }
        }
    }

